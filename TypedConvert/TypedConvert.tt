<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

using System;

<#  var types = new Type[]
    { 
        typeof(bool), 
        typeof(byte), 
        typeof(char), 
        typeof(DateTime), 
        typeof(decimal), 
        typeof(double), 
        typeof(short), 
        typeof(int), 
        typeof(long), 
        typeof(sbyte), 
        typeof(float), 
        typeof(string), 
        typeof(ushort), 
        typeof(uint), 
        typeof(ulong)
    };
#>

// <auto-generated/>
namespace TypedConvert
{
    public class Convert
    {
        public static TTo ChangeType<TFrom, TTo>(TFrom value)
        {
            return ConverterInternal<TFrom, TTo>.ConverterDelegate(value);
        }

        private static class ConverterInternal<TFrom, TTo>
        {
            public readonly static Converter<TFrom, TTo> ConverterDelegate = CreateDelegate();

            private static Type[] paramTypes = null;

            private static TTo ThrowIfCannotConvert(TFrom value) => throw new InvalidCastException();

            public static Converter<TFrom, TTo> CreateDelegate()
            {
                paramTypes = paramTypes ?? new[] { typeof(TFrom) };
                if (typeof(TFrom) == typeof(TTo))
                {
                    return (Converter<TFrom, TTo>)(object)(new Func<TFrom, TFrom>(value => value));
                }
<#
foreach (var toType in types)
{
#>
                if (typeof(TTo) == typeof(<#= toType.Name #>))
                {
                    var method = typeof(System.Convert).GetMethod("To<#= toType.Name #>", paramTypes);
                    if (method != null)
                    {
                        return (Converter<TFrom, TTo>)Delegate.CreateDelegate(typeof(Converter<TFrom, TTo>), method);
                    }
                }
<#
}
#>
                return new Converter<TFrom, TTo>(value => (TTo)System.Convert.ChangeType((object)value, typeof(TTo)));
            }
        }
    }
}